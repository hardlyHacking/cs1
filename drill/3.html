<!DOCTYPE html>
<html>
<head>
<title>Drill3</title>
<link rel=stylesheet type=text/css href="../static/css/style.css">
</head>
<body>
<h1 id="loops">Loops</h1>

<p>We&#8217;re all familiar with loops &#8211; a perfect loop, of course, is the tell-tale sign of a great GIF. For example, the famous &#8220;<a href="http://imgur.com/gallery/oL2aa2U">Bro, do you even loop</a>?&#8221; is one we&#8217;ve all seen.</p>

<p>Loops in coding are quite similar. In these loops, however, we want to do something slightly different every time rather than the <em>exact</em> same thing like in a GIF.</p>

<p>So why do we use loops? Because we&#8217;re lazy! Computer scientists are lazy people, and the lazier the better. If you can type as little as possible and still come up with a solution, that&#8217;s the best case scenario. Imagine we&#8217;re making a countdown app.</p>

<p>We <em>could</em> do this.</p>

<pre><code>print &quot;10&quot;
print &quot;9&quot;
print &quot;8&quot;
print &quot;7&quot;
print &quot;6&quot;
print &quot;5&quot;
print &quot;4&quot;
print &quot;3&quot;
print &quot;2&quot;
print &quot;1&quot;
print &quot;BLASTOFF!&quot;
</code></pre>

<p>Wow. What a pain in the Bieber. Even with copy-paste that was incredibly annoying. Surely there must be an easier way to do this! Enter loops. With loops, we can do this in just three lines of code.</p>

<h2 id="whileloops">While Loops</h2>

<p>Remember our primitive types? Yes, I <em>will</em> keep asking you about them because they&#8217;re important. Our primitive types are int, float, str, and bool. Every expression has a type. Some expressions, like <code>5 + 5</code> are integer expressions.</p>

<p>Last time in class, you learned about a special type of expression that results in a boolean value. Surprisingly, we call these <strong>boolean expressions</strong>. A simple example is <code>5 &gt; 3</code>, which evalutes to the boolean value <code>True</code>.</p>

<p>While loops have two parts: a <strong>header</strong> and a <strong>body</strong>.</p>

<p>The loop header looks like this</p>

<pre><code>while &lt;your code here&gt; :
</code></pre>

<p>That&#8217;s it. But what goes inside <code>&lt;your code here&gt;</code>? A boolean expression! <em>Any</em> boolean expression. So what&#8217;s an example of a boolean expression? Is <code>True</code> a boolean expression? Of course it is. Remember that even just a plain old vanilla value is also an expression.</p>

<p>The body of the loop looks like plain old python code, just indented one level. So let&#8217;s look at our same old count-down example.</p>

<pre><code>i = 1
while i &gt; 0:
    print str(i)
    i = i - 1
</code></pre>

<p>The most important thing to remember is that the while loop checks whether the header evalutes to <code>True</code> <em>before</em> it executes the body, not afterwards. So every single iteration, it checks that the header is still <code>True</code> and only then continues.</p>

<p>Let&#8217;s manually step through the iteration. First, <code>i</code> starts out at <code>1</code>. Obviously, <code>1 &gt; 0</code> is <code>True</code>. Great, so the loop goes on to the body and prints <code>i</code> as a string. Then, it subtracts <code>1</code> from <code>i</code>.</p>

<p>Then it goes back up to the header. It asks whether <code>0 &gt; 0</code> is <code>True</code>. Nope! It&#8217;s not. So it goes to the end of the program, <em>skipping</em> the body of the loop, and completes.</p>

<p>So let&#8217;s do some quizzes. I&#8217;ll give you code, and you tell me the output.</p>

<pre><code>i = 5
while i &gt; 3:
    j = i
    i = 0
    print str(i)
    i = j - 1
</code></pre>

<p>What&#8217;s the output?</p>

<pre><code>0
0
</code></pre>

<p>Even though the statement <code>i = 0</code> makes the loop header evaluate to <code>False</code>, the trick here is that the loop <em>only</em> checks whether the header is <code>True</code> <em>before</em> it executes the body. Once that&#8217;s true, it executes the <em>entire</em> body even if some lines of the body make the header <code>False</code>.</p>

<p>Cool, what about this one?</p>

<pre><code>while False:
    print &quot;And the winner for the Oscar is Leonardo DiCaprio!&quot;
</code></pre>

<p>There&#8217;s no output! Remember, even a literal is an expression. This particular literal <em>always</em> evaluates to <code>False</code>, so the loop <em>never</em> executes. If you have code that <em>never</em> executes no matter what, that section of code is called <strong>dead code</strong>. It&#8217;s a very bad thing to have and is often a tell-tale sign of larger problems in the code.</p>

<p>What about the opposite?</p>

<pre><code>while True:
    print &quot; Brad Pitt: 'Oh my gosh, we should adopt a child.' &quot;
</code></pre>

<p>This expression <em>always</em> evalutes to <code>True</code>, so the loop never stops executing! This is called an <strong>infinite loop</strong>, and it means your code will never finish. Uh oh!</p>

<p>So here is Blastoff once again, but with a while loop.</p>

<pre><code>i = 10
while i &gt; 0:
    print str(i)
    i = i - 1   # Could also do i -= 1
print &quot;BLASTOFF!&quot;
</code></pre>

<h2 id="forloops">For Loops</h2>

<p>There&#8217;s another type of loop called a for loop. A for loop primarily iterates over lists, so if you&#8217;re unfamiliar with lists, I&#8217;d recommend reading our section on <a href="http://chanderramesh.com/cs1/Recitation3.html">lists</a> before reading through this.</p>

<p>Much like a while loop, a for loop also has a header and a body. The body of the loop, like any loop, is just regular Python code indented further. The header for for loops, on the other hand, have a slightly different pattern from the while loop headers.</p>

<pre><code>for &lt;variable name&gt; in &lt;some iterable object&gt;:
    # Regular old loop body
    pass
</code></pre>

<p>So far, we&#8217;ve only seen lists, but there are actually other data structures that we for loops can iterate over. If you&#8217;re confused, for now you can imagine for loops as having this formula instead:</p>

<pre><code>for &lt;variable name&gt; in &lt;name of some list&gt;:
    # Regular old loop body
    pass
</code></pre>

<p>The trick here, is that <code>&lt;variable name&gt;</code>&#8217;s scope is limited to the for loop alone. In other words, the following won&#8217;t work.</p>

<pre><code>for a in [1, 2, 3, 4]:
    print a
print a
</code></pre>

<p>That second <code>print a</code> won&#8217;t work, because <code>a</code> <em>only</em> exists within that for loop.</p>

<p>One point of confusion is when to use <code>range</code>. The problem with for loops is that they <em>must</em> take a list after the <code>in</code>. So if you want to do something <code>6</code> times, but there is no list, we have to _create_one. That&#8217;s exactly what <code>range</code> does. It&#8217;s an easy way to create a list when there isn&#8217;t one.</p>

<p>So if we already have a list defined, like <code>a = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</code>, then our code just has to be this.</p>

<pre><code>for i in a:
    print str(i)
print &quot;BLASTOFF!&quot;
</code></pre>

<p>But if we don&#8217;t have that list, we have to use</p>

<pre><code>for i in range(10):
    print str(i)
print &quot;BLASTOFF!&quot;
</code></pre>

<p>Uh oh&#8230; But that&#8217;s not right. That counts upwards! So how do we fix that?</p>

<p>Turns out, the function <code>range</code> can behave differently depending on the number of parameters it takes. If it takes one parameter, it counts up from <code>0</code> to the number given. If it is given three parameters, the first is the start, the second is the end, and the third is the increment. Here, we want to countdown from <code>10</code> to <code>1</code>, with an increment of <code>-1</code>. So why do we put <code>0</code>?</p>

<p>Remember that for range, the last number is never included. So <code>range(3)</code> produces <code>[0, 1, 2]</code>. Similarly, <code>range(10, 0, -1)</code> produces <code>[10, 9, 8, 7, 6, 5, 4, 3 ,2, 1]</code>.</p>

<p>So here is our countdown example revisited with just three lines of code.</p>

<pre><code>for i in range(10, 0, -1):
    print str(i)
print &quot;BLASTOFF!&quot;
</code></pre>

<p>But <em>sometimes</em> we see <code>range</code> even when there <em>is</em> a list already defined! What gives? I&#8217;ll give you a hint &#8211; it has to do with the variable in the loop header <em>only</em> existing within the loop.</p>

<p>Let&#8217;s see if this code works.</p>

<pre><code>someList = [1, 2, 3, 4]
for item in someList:
    item = 0
print someList
</code></pre>

<p>So this code will output <code>[0, 0, 0, 0]</code>, right? Unfortunately, no. Not only is <code>item</code>&#8217;s scope limited to the for loop, it&#8217;s actually just a <em>copy</em> of the element within the actual list! It&#8217;s not the actual list element. So changing <code>item</code> does not change the list.</p>

<p>So how do we change the actual list? We use <code>range</code>.</p>

<pre><code>someList = [1, 2, 3, 4]
for i in range(len(someList)):
    someList[i] = 0
print someList
</code></pre>

<p><em>Now</em> the code will output <code>[0, 0, 0, 0]</code>. The only way to change the actual elements within a list is by indexing into the list. So the two uses for <code>range</code> is when you don&#8217;t have a list to iterate over with a for loop or you want to actually change the list through which you&#8217;re iterating.</p>

<p>In general, this results in three types of for loop headers.</p>

<p>The first type where the list is already defined.</p>

<pre><code>for &lt;variable name&gt; in &lt;list name&gt;:
    # do stuff
    pass
</code></pre>

<p>The second type where there is no list, so we have to create one with range.</p>

<pre><code>for &lt;variable name&gt; in range(&lt;number&gt;):
    # do stuff
    pass
</code></pre>

<p>And the last type where there <em>is</em> a list, but you want to <em>change</em> the values inside of that list.</p>

<pre><code>for &lt;variable name&gt; in range(len(&lt;name of list&gt;)):
    # do stuff like changing values inside the list
    # &lt;name of list&gt;[&lt;variable name&gt;] = some new value
    pass
</code></pre>

<p>Pretty neat!</p>

<h2 id="theclashofloops">The Clash of Loops</h2>

<p>So which type of loop is better?</p>

<p>Obviously, the answer is neither. Otherwise Python would have just gotten rid of the &#8220;worse&#8221; kind. The truth is different types of loops are suited for different problems. Here are circumstances where for loops excell.</p>

<ul>
<li>Do something a specific number of times</li>
<li>Iterate through a list of things</li>
</ul>

<p>In pretty much every other case, while loops are better. Pretty simple!</p>

<p>Can every program with a for loop be re-written using a while loop? What about vice versa?</p>

<p>The answer to both is yes. They are equivalent. It really is just a matter of convenience. You <em>can</em> use a while loop to go over lists, but for loops are just so much <em>easier</em> so why bother.</p>
</body>
</html>
