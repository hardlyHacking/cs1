<!DOCTYPE html>
<!-- saved from url=(0027)http://0.0.0.0:8080/drill/6 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Drill6</title>
<link rel="stylesheet" type="text/css" href="./drill6_files/style.css">
</head>
<body>
<h1 id="recursion">Recursion</h1>

<p>What is recursion? Typically, this is where we break out the references to <a href="http://www.imdb.com/title/tt1375666/?ref_=nv_sr_1">Inception</a>.</p>

<figure>
<img src="./drill6_files/a88.jpg" alt="">
<figcaption></figcaption></figure>

<p>So let’s go deeper.</p>

<h2 id="whyrecursion">Why Recursion?</h2>

<p>What is recursion? Recursion is when a function can call itself. Like this:</p>

<pre><code>def donald_trump():
    print "Donald Trump!"
    print "Who's the most handsome, awesome person in the world?"
    print "Hmm, not sure. I know! I'll ask the incredibly knowledgeable"
    donald_trump()
</code></pre>

<p>Here, the incredibly annoying <code>donald_trump</code> function is recrusive because it calls itself.</p>

<p>The opposite of the recursive approach is iteration, whic is what you have been programming in so far. Iteration is doing a series of steps, one at a time, in a linear fashion.</p>

<p><strong>Can <em>every</em> problem that is solved iteratively be solved recursively? Can <em>every</em> problem that is solved recursively be solved iteratively?</strong></p>

<p>Yes! Iterative and recursive approaches to a problem are <em>completely</em> interchangeable. So why bother using recursion?</p>

<p>Recursion is an extremely powerful tool because it allows the programmer to break down problems into smaller instances of itself. So it’s simply a matter of convenience to the programmer. Some problems are much easier to solve recursively, and thinking about it like that allows for easy solutions.</p>

<h2 id="howtorecurse">How to Recurse</h2>

<p>Every recursive function needs two critical things:</p>

<ul>
<li>A base case</li>
<li>A way to break up the problem into a smaller problem of the same kind</li>
</ul>

<p>What’s a base case? Let’s take a look at the <code>donald_trump</code> function again. What happens when we call it?</p>

<pre><code>&gt;&gt;&gt; donald_trump()
'Donald Trump!'
'Who's the most handsom, awesome person in the world?'
'Hmm, not sure. I know! I'll ask the incredibly knowledgeable'
'Donald Trump!'
'Who's the most handsom, awesome person in the world?'
'Hmm, not sure. I know! I'll ask the incredibly knowledgeable'
'Donald Trump!'
'Who's the most handsom, awesome person in the world?'
'Hmm, not sure. I know! I'll ask the incredibly knowledgeable'
'Donald Trump!'
'Who's the most handsom, awesome person in the world?'
'Hmm, not sure. I know! I'll ask the incredibly knowledgeable'
...
</code></pre>

<p>Uh oh… You see the problem. It never stops! This is recursion’s version of the infinite loop: <strong>infinite recursion</strong>. It never stops recursing! In fact, when you run this, you’ll get a <code>RuntimeError</code>.</p>

<pre><code>RuntimeError: maximum recursion depth exceeded
</code></pre>

<p>What’s a run time error? A runtime error is Python’s way of saying when I looked over your code, I couldn’t find any errors (no type errors, no syntax errors, etc). But when I actually <em>run</em> your code, a mysterious error pops up! This is the standard error Python will give you when you have a case of infinite recursion, so become familiar with it!</p>

<p>A base case is when it finally <em>stops</em> recursing. Let’s put a base in <code>donald_trump</code> so he finally stops talking.</p>

<pre><code>def donald_trump(num):
    if num &lt;= 0:
        print "Okay, I'll stop talking now."
        return
    print "Donald Trump!"
    print "Who's the most handsome, awesome person in the world?"
    print "Hmm, not sure. I know! I'll ask the incredibly knowledgeable"
    donald_trump(num - 1)
</code></pre>

<p>Great! Now, <em>eventually</em>, it will stop. In this case, the smaller problem is literally the exact <em>same</em> problem, just with <code>num</code> decremented by one.</p>

<h2 id="pitfalls">Pitfalls</h2>

<p>There are usually several common pitfalls when students first start using recursion. Let’s go over them.</p>

<ol>
<li>Infinite recursion</li>
</ol>

<p>We saw this above with the absurd <code>donald_trump</code> example. If you don’t have a base case, you’ll end up in a bad mess.</p>

<p>A problem can have multiple base cases, though. You should carefully examine what the base and recursive cases will be before you start coding to ensure you reach all of them.</p>

<p><strong>1. Return propogation</strong></p>

<p>Often times, our function needs to return something. For some reason, when recursion is introduced, students trip up over the return statement. Let’s go over a basic example.</p>

<p>Imagine that you didn’t have the <code>len</code> operator. How could you calculate the length of a list? We could do this recursively!</p>

<pre><code>def my_len(some_list, some_number):
    if some_list == []:
        return some_number
    else:
        my_len(some_list[1:], some_number + 1)
</code></pre>

<p>Will this work? No, it certainly won’t. But why not?</p>

<p>What does the base case do? It checks if the list is empty. If it is, it returns the number that we passed to it. Seems fair enough. Let’s test if the base case works.</p>

<pre><code>&gt;&gt;&gt; length = my_len([], 0)
&gt;&gt;&gt; print length
0
&gt;&gt;&gt; length = my_len([], 6)
&gt;&gt;&gt; print length
6
</code></pre>

<p>Sure enough, the base case prints whatever the number we passed to it was. Great. What about the recursive case?</p>

<pre><code>&gt;&gt;&gt; length = my_len([1], 0)
&gt;&gt;&gt; print length
None
</code></pre>

<p>Erm… What? We know from the types lecture that <code>None</code> is returned by default if the function does not return anything. That doesn’t make sense though – we are calling another function.</p>

<p>Some of you who are observant will note that <em>calling</em> a function is not the same as <em>returning</em> the value of a called function. And indeed this is the case. We are not <em>returning</em> anything in the recursive case. Having the base case alone return something is not sufficient!</p>

<p>So how do we fix this?</p>

<pre><code>def my_len(some_list, some_number):
    if some_list == []:
        return some_number
    else:
        return my_len(some_list[1:], some_number + 1)
</code></pre>

<p>Sure enough, now that we’re returning the result of the recursive case, this works as expected.</p>

<pre><code>&gt;&gt;&gt; print my_len([0, 1, 2, 3, 4, 5, 6], 0)
7
</code></pre>

<p><strong>2. Improper subproblem</strong></p>

<p>Sometimes, the second part of recursion where you break up the problem into smaller instances of the <em>same</em> problem can get tricky. Naturally, this depends on the problem at hand. Make sure you’re making the problem smaller (so it actually approaches <em>a</em> base case,) and that it is indeed the same problem.</p>

<p><strong>3. Mutual recursion</strong></p>

<p>Mutual recursion is a special case of recursion when different functions call on each other repetitively, rather than the same function.</p>

<pre><code>def even_stuff(number):
    if number == 0:
        return
    print "So much stuff I'm doing! Super important stuff."
    odd_stuff(number - 1)

def odd_stuff(number):
    print "Secret stuff. Can't know. #PRISM"
    even_stuff(number - 1)
</code></pre>

<p>Here, we have a pair of functions, <code>odd_stuff</code> and <code>even_stuff</code>, recursing on each other. Can you guess the output of <code>odd_stuff(11)</code>?</p>

<p>Notice that <code>odd_stuff</code> doesn’t have a base case here, because it depends on <code>even_stuff</code>’s base case. To be <em>really</em> safe, we could write <code>odd_stuff</code> in this way instead:</p>

<pre><code>def odd_stuff(number):
    if odd_stuff &lt; 0:
        return
    print "Secret stuff. Can't know. #PRISM"
    even_stuff(number - 1)
</code></pre>

<p>This way we are guaranteed to reach <code>even_stuff</code>’s base case on all valid inputs, while ignoring invalid inputs.</p>

</body></html>