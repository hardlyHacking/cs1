<!DOCTYPE html>
<!-- saved from url=(0029)http://0.0.0.0:8080/lecture/9 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Recitation9</title>
<link rel="stylesheet" type="text/css" href="./lecture9_files/style.css">
</head>
<body>
<h1 id="bfslab">BFS Lab</h1>

<p>The most difficult portion of this lab is understanding how the BFS algorithm works, so that is what we will be covering. The actual coding and implementation will be left up to you; after all, this is the final lab, and it’s high time we stopped babying you.</p>

<h2 id="thealgorithm">The Algorithm</h2>

<p>The key point of the breadth-first search algorithm is the queue. If you used a stack, you’d get depth-first search instead. Imagine we had a graph such as the following:</p>

<figure>
<img src="./lecture9_files/BFS.jpg" alt="">
<figcaption></figcaption></figure>

<p>Imagine we start at <code>A</code>. When we perform a BFS, the order of the nodes <strong>within the same level</strong> do not matter. So whether we choose to explore <code>B</code> or <code>C</code> first does not matter; however, we <em>cannot</em> explore <code>F</code> or <code>G</code> since those are <em>two</em> levels away.</p>

<p>So we start with level 0: <code>A</code>. First, we add it to the stack.</p>

<p>Then we pop our queue. This was fairly trivial, since only one thing was in our stack (at this level). We get back the same node, <code>A</code>. Now, we get a list of all of its neighbors.</p>

<p>Let’s imagine the list is in the following order: <code>[B, D, E, C]</code>. This is the order in which we’ll add to the stack. Our queue now has, in order, <code>B, D, E, C</code>. (<code>B</code> is first, so when we pop, that is the vertex we will receive.)</p>

<p>And that’s it! We’re done with <code>A</code>, so we continue to the next depth.</p>

<p>Now we move on to depth 1. Same thing here: we pop the stack.</p>

<p>We get a vertex, <code>B</code>. We get all of its neighbors: <code>A, F, G</code>. But wait! We already visited <code>A</code> right before this. So do we add it to the stack? Of course not. We need to maintain a dictionary of <em>visited</em> nodes to make sure we don’t visit the same node twice. Since <code>A</code> has been visited, we add <code>F</code> and <code>G</code> to the stack.</p>

<p>Our stack now looks like this: <code>C, D, E, F, G</code>.</p>

<p>We continue with depth 1. This time when we pop, we receive <code>C</code>. This node only has one neighbor – <code>A</code> – and it has already been visited! So nothing much to do here. Same thing with vertices <code>D</code> and <code>E</code>.</p>

<p>Now we are done with depth 1, so we can finish up with the final depth 2.</p>

<p>The process is fairly similar for each vertex:</p>

<pre><code>* Pop the queue
* Mark the vertex as visited
* Get a list of all of the neighbors
* Add any neighbor that isn't already visited to the queue
</code></pre>

<p>And we keep going until the queue is empty! That’s it for BFS!</p>

</body></html>